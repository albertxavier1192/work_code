/* Implementation of remote procedure calls.
 */

#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include <rpc/rpc.h>
#include <sys/types.h>
#include <sys/socket.h>
#include "test_nopmap.h"

char **
test_hello_1_svc (char **str, struct svc_req *req)
{
  static char *ptr;
  int len = strlen (*str);
  /* XXX What cleans up this string? */
  ptr = malloc (6 + len + 1);
  strcpy (ptr, "Hello ");
  strcpy (ptr+6, *str);
  printf ("%s\n", ptr);
  return &ptr;
}

char **
test_ctime_1_svc (void *v, struct svc_req *req)
{
  static char *ptr;
  time_t t;
  time (&t);
  ptr = ctime (&t);
  return &ptr;
}

/* This is autogenerated, in test_nopmap_svc.c */
extern void testprog_1 (struct svc_req *rqstp, register SVCXPRT *transp);

/* In this case we have to supply main() because
 * we want to provide one which listens on our chosen
 * port.  This is based on the auto-generated version
 * (see test_svc.c).
 */
int
main (int argc, char **argv)
{
  int sock = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock == -1) { perror ("socket"); exit (1); }

  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_port = htons (5000);
  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK); // listen only on 127.0.0.1
  if (bind (sock, (struct sockaddr *) &addr, sizeof addr) == -1)
    { perror ("bind"); exit (1); }

  /* Documentation states: "If the socket is not bound to a local TCP
   * port, then this routine binds it to an arbitrary port."
   * In fact svctcp_create tries to bind the socket again, which
   * fails (because it is already bound above), and this error is
   * ignored.  The end result seems to be correct, however if
   * stracing you'll see some strange things.
   */
  SVCXPRT *transp = svctcp_create (sock, 0, 0);
  if (!transp) {
    fprintf (stderr, "cannot create tcp service\n");
    exit (1);
  }
  /* Because final arg is 0, this will not register with portmap. */
  if (!svc_register (transp, TESTPROG, TESTPROG_VERS1, testprog_1, 0)) {
    fprintf (stderr, "unable to register (TESTPROG, TESTPROG_VERS1, 0)\n");
    exit (1);
  }

  svc_run ();
  fprintf (stderr, "svc_run returned\n");
  exit (1);
  /* NOTREACHED */
}
