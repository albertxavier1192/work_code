/* Implementation of remote procedure calls.
 */

#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include <rpc/rpc.h>
#include <sys/types.h>
#include <sys/socket.h>
#include "test_batch.h"

static int count = 0; // Returned by test_num_calls ()

void *
test_batch1_1_svc (char **str, struct svc_req *req)
{
  printf ("batch1: %s\n", *str);
  count++;
  return 0;
}

void *
test_batch2_1_svc (char **str, struct svc_req *req)
{
  printf ("batch2: %s\n", *str);
  count++;
  return 0;
}

void *
test_batch3_1_svc (char **str, struct svc_req *req)
{
  printf ("batch3: %s\n", *str);
  count++;
  return 0;
}

int *
test_num_calls_1_svc (void *vp, struct svc_req *req)
{
  static int c;
  c = count;
  count = 0;
  return &c;
}

/* This is autogenerated, in test_batch_svc.c */
extern void testprog_1 (struct svc_req *rqstp, register SVCXPRT *transp);

/* In this case we have to supply main() because
 * we want to provide one which listens on our chosen
 * port.  This is based on the auto-generated version
 * (see test_svc.c).
 */
int
main (int argc, char **argv)
{
  int sock = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (sock == -1) { perror ("socket"); exit (1); }

  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_port = htons (5000);
  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK); // listen only on 127.0.0.1
  if (bind (sock, (struct sockaddr *) &addr, sizeof addr) == -1)
    { perror ("bind"); exit (1); }

  /* Documentation states: "If the socket is not bound to a local TCP
   * port, then this routine binds it to an arbitrary port."
   * In fact svctcp_create tries to bind the socket again, which
   * fails (because it is already bound above), and this error is
   * ignored.  The end result seems to be correct, however if
   * stracing you'll see some strange things.
   */
  SVCXPRT *transp = svctcp_create (sock, 0, 0);
  if (!transp) {
    fprintf (stderr, "cannot create tcp service\n");
    exit (1);
  }
  /* Because final arg is 0, this will not register with portmap. */
  if (!svc_register (transp, TESTPROG, TESTPROG_VERS1, testprog_1, 0)) {
    fprintf (stderr, "unable to register (TESTPROG, TESTPROG_VERS1, 0)\n");
    exit (1);
  }

  svc_run ();
  fprintf (stderr, "svc_run returned\n");
  exit (1);
  /* NOTREACHED */
}
